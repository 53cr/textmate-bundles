{
	//
	// Generic Lisp.
	// chris@cjack.com
	// Feel free to send additions and modifications.
	//
	// This is a tiny, tiny subset of the enormous ANSI Common Lisp language.
	// More may be added, but probably to a superset "Common Lisp" syntax... (some of this should probably be moved to such a file, in fact)
	// This file should ideally be a basis for Scheme and other consistently S-expression-only dialects of Lisp. Maybe.
	//
	
	comment = "";
	
	name = "Lisp";
	scopeName = "source.lisp";
	fileTypes = ( lisp, cl, l, mud, el, scm, sch );		// mud is for the Zork MDL source; el is Emacs lisp.
														// Not that we really handle MDL, but it's a little more pleasant, at least.
														// scm and sch are Scheme, which really needs a superset syntax file of it's own.
	foldingStartMarker = "\\(";
	foldingStopMarker = "\\)";
	increaseIndentPattern = "^.*\\(.*[^)\"]$";
	smartTypingPairs = (
	   ( "(", ")" ), ( "[", "]" ), ( "{", "}" ), ( "\"", "\"" )
	);
	highlightPairs = (
	   ( "(", ")" ), ( "[", "]" ), ( "{", "}" )
	);
	patterns = (
		{ name = "comment.line.lisp"; match = ";.*$"; },
		
		{
			name = "declaration.function.lisp";
			match = "(\\b(?i:(defun|defmethod|defmacro))\\b)(\\s+)((\\w|\\-|\\!|\\?)*)";
				captures = {
				    2 = { name = "storage.type.function-type.lisp"; };
				    4 = { name = "entity.name.function.lisp"; };
				};
		},
		
		{
			// better class? function #'+ or character constant #\a (might want to highlight these two constructs differently)
			name = "constant.character.lisp";
			match = "#(\\w|[\\\\+-=<>'\"&#])+";
		},

// Need to think about how to make this work properly. Both atoms and lists can be quoted.
//		{
//			name = "Quoted Element1";
//			match = "'(\\w|[\\\\+-=<>'\"&#\\(\\)])+";
//			foregroundColor = "#0000CD";
//		},
		
//		{
//			name = "Quoted Element2";
//			begin = "'\\("; end = "\\)";
//			foregroundColor = "#0000CD";
//		},
		
		{   name = "variable.other.global.lisp";
			match = "\\*(\\S*)\\*";
		},
		
		{ name = "keyword.control.lisp"; match = "\\b(?i:case|do|let|loop|if|else|when)\\b"; },
		{ name = "keyword.operator.lisp"; match = "\\b(?i:eq|neq|and|or)\\b"; },
		{ name = "constant.language.lisp"; match = "\\b(?i:null|nil)\\b"; },
		{ name = "support.function.lisp"; match = "\\b(?i:cons|car|cdr|cond|lambda|format|setq|setf|quote|eval|append|list|listp|memberp|t|load|progn)\\b"; },

		{ name = "constant.numeric.lisp"; match = "\\b((0(x|X)[0-9a-fA-F]*)|(([0-9]+\\.?[0-9]*)|(\\.[0-9]+))((e|E)(\\+|-)?[0-9]+)?)(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\\b";},
		{ name = "string.quoted.double.lisp"; begin = "\""; end = "\""; swallow = "\\\\."; },
	);
	uuid = "00D451C9-6B1D-11D9-8DFA-000D93589AF6";
}
